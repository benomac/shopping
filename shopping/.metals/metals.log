[0m2021.03.27 17:42:23 INFO  Started: Metals version 0.10.0 in workspace '/Users/benomac/code/scala/shopping/shopping' for client vscode 1.54.3.[0m
[0m2021.03.27 17:42:25 INFO  time: initialize in 1.77s[0m
[0m2021.03.27 17:42:26 INFO  Attempting to connect to the build server...[0m
Starting the bsp launcher for bloop...
Opening a bsp server connection with 'bsp --protocol local --socket /var/folders/vr/h7n_c7ms1392t22029prklq40000gn/T/bsp-launcher12923435379129068241/bsp.socket'...
[0m2021.03.27 17:42:25 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
[0m2021.03.27 17:42:31 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
Waiting for the bsp connection to come up...


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 17:42:34 INFO  time: code lens generation in 8.12s[0m
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
Waiting for the bsp connection to come up...
No server running at 127.0.0.1:8212, let's fire one...
Resolving ch.epfl.scala:bloop-frontend_2.12:1.4.8...
Starting bloop server at 127.0.0.1:8212...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
Attempting a connection to the server...
[0m[32m[D][0m Waiting for a connection at local:///var/folders/vr/h7n_c7ms1392t22029prklq40000gn/T/bsp-launcher12923435379129068241/bsp.socket...
The server is listening for incoming connections at local:///var/folders/vr/h7n_c7ms1392t22029prklq40000gn/T/bsp-launcher12923435379129068241/bsp.socket...
Starting thread that pumps stdin and redirects it to the bsp server...
Starting thread that pumps server stdout and redirects it to the client stdout...
[0m2021.03.27 17:42:44 INFO  tracing is disabled for protocol BSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /Users/benomac/Library/Caches/org.scalameta.metals/bsp.trace.json[0m
[0m2021.03.27 17:42:44 INFO  time: Connected to build server in 18s[0m
[0m2021.03.27 17:42:44 INFO  Connected to Build server: Bloop v1.4.8[0m
[0m2021.03.27 17:42:45 ERROR Empty build targets. Expected at least one build target identifier.[0m
[0m2021.03.27 17:42:45 ERROR Empty build targets. Expected at least one build target identifier.[0m
[0m2021.03.27 17:42:45 ERROR Empty build targets. Expected at least one build target identifier.[0m
[0m2021.03.27 17:42:46 INFO  time: indexed workspace in 1.59s[0m
[0m2021.03.27 17:42:46 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
[0m2021.03.27 17:42:48 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 17:54:22 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/funk.scala[0m





object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 5:54:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 38


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}

Mar 27, 2021 5:54:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 51



Mar 27, 2021 5:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 2 is not a valid line number, allowed [0..0]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 2 is not a valid line number, allowed [0..0]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.IllegalArgumentException: 2 is not a valid line number, allowed [0..0]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more




object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 5:54:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 65


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}

Mar 27, 2021 5:55:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 73












object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 5:55:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 114


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}

Mar 27, 2021 5:55:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 124




[0m2021.03.27 17:55:36 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/funk.scala[0m
object funk extends App {
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 5:55:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 138


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 17:56:05 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object funk extends App {
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
Mar 27, 2021 5:56:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 172
object funk extends App {
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 5:56:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 178
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 17:56:15 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 17:56:48 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import funk._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 17:56:59 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 5:56:59 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: identifier expected but object found
object Main extends App {
^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: identifier expected but object found
object Main extends App {
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser.stableId(ScalametaParser.scala:1928)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$importer$1(ScalametaParser.scala:3851)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.importer(ScalametaParser.scala:3850)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$importStmt$2(ScalametaParser.scala:3844)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$importStmt$1(ScalametaParser.scala:3844)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.importStmt(ScalametaParser.scala:3842)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4824)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

import

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 5:57:01 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: identifier expected but object found
object Main extends App {
^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: identifier expected but object found
object Main extends App {
^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.name(ScalametaParser.scala:1829)
	at scala.meta.internal.parsers.ScalametaParser.termName(ScalametaParser.scala:1832)
	at scala.meta.internal.parsers.ScalametaParser.path(ScalametaParser.scala:1863)
	at scala.meta.internal.parsers.ScalametaParser.stableId(ScalametaParser.scala:1928)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$importer$1(ScalametaParser.scala:3851)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.importer(ScalametaParser.scala:3850)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$importStmt$2(ScalametaParser.scala:3844)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$importStmt$1(ScalametaParser.scala:3844)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.importStmt(ScalametaParser.scala:3842)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4824)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.27 17:57:02 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 17:57:14 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 17:57:43 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:05:46 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/test/scala/ShoppingSpec.scala[0m
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import Main._

class ShoppingSpec extends AnyFlatSpec with Matchers {
    
    // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)
    
    val costs = Map('a' -> Price(50, 3, 130), 
                     'b' -> Price(30, 2, 45), 
                     'c' -> Price(20, 0, 0), 
                     'd' -> Price(15, 0, 0))

    behavior of "costs"   

    it should "get the price for 'a'" in {
        costs('a').price shouldBe 50
    }           

    it should "get the numForDeal for 'a' " in {
        costs('a').numForDeal shouldBe 3
    }

    it should "get the priceForDeal for 'a' " in {
        costs('a').priceForDeal shouldBe 130
    }

    it should "not get the price for 'a'" in {
        costs('b').priceForDeal should not be 130
    }
    
    
    
    behavior of "priceForDeals"

    it should "return the cost for the amount of deals" in {
        priceForDeals(3, costs('a')) shouldBe 130
    }

    it should "not return the price for the deal" in {
        priceForDeals(1, costs('a')) should not be 130
    }


    behavior of "priceForNoDeals" 

    it should "return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) shouldBe 50
    }

    it should "not return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) should not be 130
    }


    behavior of "priceWhenItemHasNoDealValues" 

    it should "return the price for a number of items that have no deal values" in {
        priceWhenItemHasNoDealValues(3, costs('c')) shouldBe 60
    }

    


    behavior of "checkItemIsValid"

    it should "return true" in {
        checkItemIsValid('a', costs) shouldBe true
    }

    it should "return false" in {
        checkItemIsValid('x', costs) shouldBe false
    }

}
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import Main._

class ShoppingSpec extends AnyFlatSpec with Matchers {
    
    // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)
    
    val costs = Map('a' -> Price(50, 3, 130), 
                     'b' -> Price(30, 2, 45), 
                     'c' -> Price(20, 0, 0), 
                     'd' -> Price(15, 0, 0))

    behavior of "costs"   

    it should "get the price for 'a'" in {
        costs('a').price shouldBe 50
    }           

    it should "get the numForDeal for 'a' " in {
        costs('a').numForDeal shouldBe 3
    }

    it should "get the priceForDeal for 'a' " in {
        costs('a').priceForDeal shouldBe 130
    }

    it should "not get the price for 'a'" in {
        costs('b').priceForDeal should not be 130
    }
    
    
    
    behavior of "priceForDeals"

    it should "return the cost for the amount of deals" in {
        priceForDeals(3, costs('a')) shouldBe 130
    }

    it should "not return the price for the deal" in {
        priceForDeals(1, costs('a')) should not be 130
    }


    behavior of "priceForNoDeals" 

    it should "return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) shouldBe 50
    }

    it should "not return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) should not be 130
    }


    behavior of "priceWhenItemHasNoDealValues" 

    it should "return the price for a number of items that have no deal values" in {
        priceWhenItemHasNoDealValues(3, costs('c')) shouldBe 60
    }

    


    behavior of "checkItemIsValid"

    it should "return true" in {
        checkItemIsValid('a', costs) shouldBe true
    }

    it should "return false" in {
        checkItemIsValid('x', costs) shouldBe false
    }

}
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import Main._

class ShoppingSpec extends AnyFlatSpec with Matchers {
    
    // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)
    
    val costs = Map('a' -> Price(50, 3, 130), 
                     'b' -> Price(30, 2, 45), 
                     'c' -> Price(20, 0, 0), 
                     'd' -> Price(15, 0, 0))

    behavior of "costs"   

    it should "get the price for 'a'" in {
        costs('a').price shouldBe 50
    }           

    it should "get the numForDeal for 'a' " in {
        costs('a').numForDeal shouldBe 3
    }

    it should "get the priceForDeal for 'a' " in {
        costs('a').priceForDeal shouldBe 130
    }

    it should "not get the price for 'a'" in {
        costs('b').priceForDeal should not be 130
    }
    
    
    
    behavior of "priceForDeals"

    it should "return the cost for the amount of deals" in {
        priceForDeals(3, costs('a')) shouldBe 130
    }

    it should "not return the price for the deal" in {
        priceForDeals(1, costs('a')) should not be 130
    }


    behavior of "priceForNoDeals" 

    it should "return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) shouldBe 50
    }

    it should "not return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) should not be 130
    }


    behavior of "priceWhenItemHasNoDealValues" 

    it should "return the price for a number of items that have no deal values" in {
        priceWhenItemHasNoDealValues(3, costs('c')) shouldBe 60
    }

    


    behavior of "checkItemIsValid"

    it should "return true" in {
        checkItemIsValid('a', costs) shouldBe true
    }

    it should "return false" in {
        checkItemIsValid('x', costs) shouldBe false
    }

}
[0m2021.03.27 18:05:56 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m










[0m2021.03.27 18:06:09 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:06:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 267


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
}
Mar 27, 2021 6:06:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 273
object Utes {
    
}
object Utes {
    
}
object Utes {
    
}
object Utes {
    
}
[0m2021.03.27 18:06:18 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:06:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 286


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:06:37 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
Mar 27, 2021 6:06:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 330
object Utes {
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
object Utes {
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
object Utes {
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
object Utes {
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
[0m2021.03.27 18:06:58 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
import Utes._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:07:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 353
import Utes._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:07:23 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
Mar 27, 2021 6:07:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 371
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }
}
[0m2021.03.27 18:07:53 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:07:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 391
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala
package collection
package immutable

import generic._
import parallel.immutable.ParMap

/**
 *  A generic template for immutable maps from keys of type `K`
 *  to values of type `V`.
 *  To implement a concrete map, you need to provide implementations of the
 *  following methods (where `This` is the type of the actual map implementation):
 *
 *  {{{
 *    def get(key: K): Option[V]
 *    def iterator: Iterator[(K, V)]
 *    def + [V1 >: V](kv: (K, V)): Map[K, V1]
 *    def - (key: K): This
 *  }}}
 *
 *  If you wish that transformer methods like `take`, `drop`, `filter` return the
 *  same kind of map, you should also override:
 *
 *  {{{
 *    def empty: This
 *  }}}
 *
 *  It is also good idea to override methods `foreach` and
 *  `size` for efficiency.
 *
 *  @tparam K     the type of the keys contained in this collection.
 *  @tparam V     the type of the values associated with the keys.
 *  @tparam This  The type of the actual map implementation.
 *
 *  @author  Martin Odersky
 *  @since   2.8
 *  @define Coll immutable.Map
 *  @define coll immutable map
 */
trait MapLike[K, +V, +This <: MapLike[K, V, This] with Map[K, V]]
  extends scala.collection.MapLike[K, V, This]
     with Parallelizable[(K, V), ParMap[K, V]]
{
self =>

  protected[this] override def parCombiner = ParMap.newCombiner[K, V]

  /** A new immutable map containing updating this map with a given key/value mapping.
   *  @param    key the key
   *  @param    value the value
   *  @return   A new map with the new key/value mapping
   */
  override def updated [V1 >: V](key: K, value: V1): immutable.Map[K, V1] = this + ((key, value))

  /** Add a key/value pair to this map, returning a new map.
   *  @param    kv the key/value pair.
   *  @return   A new map with the new binding added to this map.
   */
  def + [V1 >: V] (kv: (K, V1)): immutable.Map[K, V1]

  /** Adds two or more elements to this collection and returns
   *  a new collection.
   *
   *  @param elem1 the first element to add.
   *  @param elem2 the second element to add.
   *  @param elems the remaining elements to add.
   *  @return A new map with the new bindings added to this map.
   */
  override def + [V1 >: V] (elem1: (K, V1), elem2: (K, V1), elems: (K, V1) *): immutable.Map[K, V1] =
    this + elem1 + elem2 ++ elems

  /** Adds a number of elements provided by a traversable object
   *  and returns a new collection with the added elements.
   *
   *  @param xs      the traversable object consisting of key-value pairs.
   *  @return        a new immutable map with the bindings of this map and those from `xs`.
   */
  override def ++[V1 >: V](xs: GenTraversableOnce[(K, V1)]): immutable.Map[K, V1] =
    ((repr: immutable.Map[K, V1]) /: xs.seq) (_ + _)

  /** Filters this map by retaining only keys satisfying a predicate.
   *  @param  p   the predicate used to test keys
   *  @return an immutable map consisting only of those key value pairs of this map where the key satisfies
   *          the predicate `p`. The resulting map wraps the original map without copying any elements.
   */
  override def filterKeys(p: K => Boolean): Map[K, V] = new FilteredKeys(p) with DefaultMap[K, V]

  /** Transforms this map by applying a function to every retrieved value.
   *  @param  f   the function used to transform values of this map.
   *  @return a map view which maps every key of this map
   *          to `f(this(key))`. The resulting map wraps the original map without copying any elements.
   */
  override def mapValues[W](f: V => W): Map[K, W] = new MappedValues(f) with DefaultMap[K, W]

  /** Collects all keys of this map in a set.
   *  @return  a set containing all keys of this map.
   */
  override def keySet: immutable.Set[K] = new ImmutableDefaultKeySet

  protected class ImmutableDefaultKeySet extends super.DefaultKeySet with immutable.Set[K] {
    override def + (elem: K): immutable.Set[K] =
      if (this(elem)) this
      else immutable.Set[K]() ++ this + elem
    override def - (elem: K): immutable.Set[K] =
      if (this(elem)) immutable.Set[K]() ++ this - elem
      else this
      
    // ImmutableDefaultKeySet is only protected, so we won't warn on override.
    // Someone could override in a way that makes widening not okay
    // (e.g. by overriding +, though the version in this class is fine)
    override def toSet[B >: K]: Set[B] = this.asInstanceOf[Set[B]]
  }

  /** This function transforms all the values of mappings contained
   *  in this map with function `f`.
   *
   *  @param f A function over keys and values
   *  @return  the updated map
   */
  def transform[W, That](f: (K, V) => W)(implicit bf: CanBuildFrom[This, (K, W), That]): That = {
    val b = bf(repr)
    for ((key, value) <- this) b += ((key, f(key, value)))
    b.result()
  }
}

import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:07:58 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
Mar 27, 2021 6:08:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 409
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import Main._

class ShoppingSpec extends AnyFlatSpec with Matchers {
    
    // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)
    
    val costs = Map('a' -> Price(50, 3, 130), 
                     'b' -> Price(30, 2, 45), 
                     'c' -> Price(20, 0, 0), 
                     'd' -> Price(15, 0, 0))

    behavior of "costs"   

    it should "get the price for 'a'" in {
        costs('a').price shouldBe 50
    }           

    it should "get the numForDeal for 'a' " in {
        costs('a').numForDeal shouldBe 3
    }

    it should "get the priceForDeal for 'a' " in {
        costs('a').priceForDeal shouldBe 130
    }

    it should "not get the price for 'a'" in {
        costs('b').priceForDeal should not be 130
    }
    
    
    
    behavior of "priceForDeals"

    it should "return the cost for the amount of deals" in {
        priceForDeals(3, costs('a')) shouldBe 130
    }

    it should "not return the price for the deal" in {
        priceForDeals(1, costs('a')) should not be 130
    }


    behavior of "priceForNoDeals" 

    it should "return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) shouldBe 50
    }

    it should "not return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) should not be 130
    }


    behavior of "priceWhenItemHasNoDealValues" 

    it should "return the price for a number of items that have no deal values" in {
        priceWhenItemHasNoDealValues(3, costs('c')) shouldBe 60
    }

    


    behavior of "checkItemIsValid"

    it should "return true" in {
        checkItemIsValid('a', costs) shouldBe true
    }

    it should "return false" in {
        checkItemIsValid('x', costs) shouldBe false
    }

}
Mar 27, 2021 6:08:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 418
import org.scalatest.flatspec.AnyFlatSpec
import org.scalatest.matchers.should.Matchers
import Main._

class ShoppingSpec extends AnyFlatSpec with Matchers {
    
    // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)
    
    val costs = Map('a' -> Price(50, 3, 130), 
                     'b' -> Price(30, 2, 45), 
                     'c' -> Price(20, 0, 0), 
                     'd' -> Price(15, 0, 0))

    behavior of "costs"   

    it should "get the price for 'a'" in {
        costs('a').price shouldBe 50
    }           

    it should "get the numForDeal for 'a' " in {
        costs('a').numForDeal shouldBe 3
    }

    it should "get the priceForDeal for 'a' " in {
        costs('a').priceForDeal shouldBe 130
    }

    it should "not get the price for 'a'" in {
        costs('b').priceForDeal should not be 130
    }
    
    
    
    behavior of "priceForDeals"

    it should "return the cost for the amount of deals" in {
        priceForDeals(3, costs('a')) shouldBe 130
    }

    it should "not return the price for the deal" in {
        priceForDeals(1, costs('a')) should not be 130
    }


    behavior of "priceForNoDeals" 

    it should "return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) shouldBe 50
    }

    it should "not return the price for left over item that didn't make the deal" in {
        priceForNoDeals(4, costs('a')) should not be 130
    }


    behavior of "priceWhenItemHasNoDealValues" 

    it should "return the price for a number of items that have no deal values" in {
        priceWhenItemHasNoDealValues(3, costs('c')) shouldBe 60
    }

    


    behavior of "checkItemIsValid"

    it should "return true" in {
        checkItemIsValid('a', costs) shouldBe true
    }

    it should "return false" in {
        checkItemIsValid('x', costs) shouldBe false
    }

}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:08:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 424
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:08:40 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
Mar 27, 2021 6:08:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 454
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
[0m2021.03.27 18:08:52 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:09:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 460
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:09:13 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:09:13 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:09:13 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  
}
Mar 27, 2021 6:09:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 473
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  
}
[0m2021.03.27 18:09:16 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:09:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 484
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:09:34 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }
}
Mar 27, 2021 6:09:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 510
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }
}
[0m2021.03.27 18:09:57 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:09:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 527
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:10:01 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }
}
Mar 27, 2021 6:10:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 541
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }
}
[0m2021.03.27 18:10:16 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:10:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 555
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:10:23 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:10:33 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }
}
Mar 27, 2021 6:10:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 571
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }
}
[0m2021.03.27 18:10:40 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:10:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 592
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:10:54 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:10:57 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 
}
Mar 27, 2021 6:11:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 619
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 
}
[0m2021.03.27 18:11:17 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:11:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 641
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:11:20 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:11:51 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
Mar 27, 2021 6:12:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 665
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
}
[0m2021.03.27 18:12:04 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Utes.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:12:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 674
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:14:01 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Utes._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:14:07 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:14:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 701
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Utes {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
[0m2021.03.27 18:14:23 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:14:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 724
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
Mar 27, 2021 6:15:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 794
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala
package collection
package generic

/** A template trait that contains just the `map`, `flatMap`, `foreach` and `withFilter` methods
 *  of trait `TraversableLike`.
 */
trait FilterMonadic[+A, +Repr] extends Any {
  def map[B, That](f: A => B)(implicit bf: CanBuildFrom[Repr, B, That]): That
  def flatMap[B, That](f: A => scala.collection.GenTraversableOnce[B])(implicit bf: CanBuildFrom[Repr, B, That]): That
  def foreach[U](f: A => U): Unit
  def withFilter(p: A => Boolean): FilterMonadic[A, Repr]
}

import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:18:51 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:19:09 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
something's wrong: no file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala in Map[Char,<error>]RangePosition(file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala, 80, 80, 99)
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
something's wrong: no file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala in Map[Char,<error>]RangePosition(file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala, 80, 80, 92)
something's wrong: no file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala in Map[Char,<error>]RangePosition(file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala, 80, 80, 93)
something's wrong: no file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala in Map[Char,Int]RangePosition(file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala, 80, 80, 94)
import Yoots._

object Main extends App {

  def total (products: Price, items: String): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
[0m2021.03.27 18:19:33 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char, Int]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char, Int]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char, Int]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char, Int]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
[0m2021.03.27 18:19:49 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
import Yoots._

object Main extends App {

  def total (products: Price, items: Map[Char,Yoots.Price]): Int = {
    for ((key,value) <- createToBuyMap(items)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
    

  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
[0m2021.03.27 18:20:46 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:20:51 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
something's wrong: no file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala in Map[Char,Main.Price]RangePosition(file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala, 918, 918, 934)


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala

import scala.language.implicitConversions

import scala.collection.{ mutable, immutable, generic }
import immutable.StringOps
import mutable.ArrayOps
import generic.CanBuildFrom
import scala.annotation.{ elidable, implicitNotFound }
import scala.annotation.elidable.ASSERTION
import scala.io.StdIn

/** The `Predef` object provides definitions that are accessible in all Scala
 *  compilation units without explicit qualification.
 *
 *  === Commonly Used Types ===
 *  Predef provides type aliases for types which are commonly used, such as
 *  the immutable collection types [[scala.collection.immutable.Map]],
 *  [[scala.collection.immutable.Set]], and the [[scala.collection.immutable.List]]
 *  constructors ([[scala.collection.immutable.::]] and
 *  [[scala.collection.immutable.Nil]]).
 *
 *  === Console Output ===
 *  For basic console output, `Predef` provides convenience methods [[print(x:Any* print]] and [[println(x:Any* println]],
 *  which are aliases of the methods in the object [[scala.Console]].
 *
 *  === Assertions ===
 *  A set of `assert` functions are provided for use as a way to document
 *  and dynamically check invariants in code. Invocations of `assert` can be elided
 *  at compile time by providing the command line option `-Xdisable-assertions`,
 *  which raises `-Xelide-below` above `elidable.ASSERTION`, to the `scalac` command.
 *
 *  Variants of `assert` intended for use with static analysis tools are also
 *  provided: `assume`, `require` and `ensuring`. `require` and `ensuring` are
 *  intended for use as a means of design-by-contract style specification
 *  of pre- and post-conditions on functions, with the intention that these
 *  specifications could be consumed by a static analysis tool. For instance,
 *
 *  {{{
 *  def addNaturals(nats: List[Int]): Int = {
 *    require(nats forall (_ >= 0), "List contains negative numbers")
 *    nats.foldLeft(0)(_ + _)
 *  } ensuring(_ >= 0)
 *  }}}
 *
 *  The declaration of `addNaturals` states that the list of integers passed should
 *  only contain natural numbers (i.e. non-negative), and that the result returned
 *  will also be natural. `require` is distinct from `assert` in that if the
 *  condition fails, then the caller of the function is to blame rather than a
 *  logical error having been made within `addNaturals` itself. `ensuring` is a
 *  form of `assert` that declares the guarantee the function is providing with
 *  regards to its return value.
 *
 *  === Implicit Conversions ===
 *  A number of commonly applied implicit conversions are also defined here, and
 *  in the parent type [[scala.LowPriorityImplicits]]. Implicit conversions
 *  are provided for the "widening" of numeric values, for instance, converting a
 *  Short value to a Long value as required, and to add additional higher-order
 *  functions to Array values. These are described in more detail in the documentation of [[scala.Array]].
 *
 * @groupname utilities Utility Methods
 * @groupprio utilities 10
 *
 * @groupname assertions Assertions
 * @groupprio assertions 20
 * @groupdesc assertions These methods support program verification and runtime correctness.
 *
 * @groupname console-output Console Output
 * @groupprio console-output 30
 * @groupdesc console-output These methods provide output via the console.
 *
 * @groupname type-constraints Type Constraints
 * @groupprio type-constraints 40
 * @groupdesc type-constraints These entities allows constraints between types to be stipulated.
 *
 * @groupname aliases Aliases
 * @groupprio aliases 50
 * @groupdesc aliases These aliases bring selected immutable types into scope without any imports.
 *
 * @groupname conversions-string String Conversions
 * @groupprio conversions-string 60
 * @groupdesc conversions-string Conversions to and from String and StringOps.
 *
 * @groupname implicit-classes-any Implicit Classes
 * @groupprio implicit-classes-any 70
 * @groupdesc implicit-classes-any These implicit classes add useful extension methods to every type.
 *
 * @groupname char-sequence-wrappers CharSequence Wrappers
 * @groupprio char-sequence-wrappers 80
 * @groupdesc char-sequence-wrappers Wrappers that implements CharSequence and were implicit classes.
 *
 * @groupname conversions-java-to-anyval Java to Scala
 * @groupprio conversions-java-to-anyval 90
 * @groupdesc conversions-java-to-anyval Implicit conversion from Java primitive wrapper types to Scala equivalents.
 *
 * @groupname conversions-anyval-to-java Scala to Java
 * @groupprio conversions-anyval-to-java 100
 * @groupdesc conversions-anyval-to-java Implicit conversion from Scala AnyVals to Java primitive wrapper types equivalents.
 *
 * @groupname conversions-array-to-wrapped-array Array to WrappedArray
 * @groupprio conversions-array-to-wrapped-array 110
 * @groupdesc conversions-array-to-wrapped-array Conversions from Arrays to WrappedArrays.
 */
object Predef extends LowPriorityImplicits with DeprecatedPredef {
  /**
   * Retrieve the runtime representation of a class type. `classOf[T]` is equivalent to
   * the class literal `T.class` in Java.
   *
   * @example {{{
   * val listClass = classOf[List[_]]
   * // listClass is java.lang.Class[List[_]] = class scala.collection.immutable.List
   *
   * val mapIntString = classOf[Map[Int,String]]
   * // mapIntString is java.lang.Class[Map[Int,String]] = interface scala.collection.immutable.Map
   * }}}
   * @group utilities
   */
  def classOf[T]: Class[T] = null // This is a stub method. The actual implementation is filled in by the compiler.

  /** The `String` type in Scala has methods that come either from the underlying
   *  Java String (see the documentation corresponding to your Java version, for
   *  example [[http://docs.oracle.com/javase/8/docs/api/java/lang/String.html]]) or
   *  are added implicitly through [[scala.collection.immutable.StringOps]].
   *  @group aliases
   */
  type String        = java.lang.String
  /**  @group aliases */
  type Class[T]      = java.lang.Class[T]

  // miscellaneous -----------------------------------------------------
  scala.`package`                         // to force scala package object to be seen.
  scala.collection.immutable.List         // to force Nil, :: to be seen.

  /**  @group aliases */
  type Function[-A, +B] = Function1[A, B]

  /**  @group aliases */
  type Map[A, +B] = immutable.Map[A, B]
  /**  @group aliases */
  type Set[A]     = immutable.Set[A]
  /**  @group aliases */
  val Map         = immutable.Map
  /**  @group aliases */
  val Set         = immutable.Set

  // Manifest types, companions, and incantations for summoning
  @annotation.implicitNotFound(msg = "No ClassManifest available for ${T}.")
  @deprecated("use `scala.reflect.ClassTag` instead", "2.10.0")
  type ClassManifest[T] = scala.reflect.ClassManifest[T]
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
  type OptManifest[T]   = scala.reflect.OptManifest[T]
  @annotation.implicitNotFound(msg = "No Manifest available for ${T}.")
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead", "2.10.0")
  type Manifest[T]      = scala.reflect.Manifest[T]
  @deprecated("use `scala.reflect.ClassTag` instead", "2.10.0")
  val ClassManifest     = scala.reflect.ClassManifest
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("use `scala.reflect.ClassTag` (to capture erasures) or scala.reflect.runtime.universe.TypeTag (to capture types) or both instead", "2.10.0")
  val Manifest          = scala.reflect.Manifest
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
  val NoManifest        = scala.reflect.NoManifest

  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("use scala.reflect.classTag[T] and scala.reflect.runtime.universe.typeTag[T] instead", "2.10.0")
  def manifest[T](implicit m: Manifest[T])           = m
  @deprecated("use scala.reflect.classTag[T] instead", "2.10.0")
  def classManifest[T](implicit m: ClassManifest[T]) = m
  // TODO undeprecated until Scala reflection becomes non-experimental
  // @deprecated("this notion doesn't have a corresponding concept in 2.10, because scala.reflect.runtime.universe.TypeTag can capture arbitrary types. Use type tags instead of manifests, and there will be no need in opt manifests.", "2.10.0")
  def optManifest[T](implicit m: OptManifest[T])     = m

  // Minor variations on identity functions
  /** @group utilities */
  @inline def identity[A](x: A): A         = x    // @see `conforms` for the implicit version
  /** @group utilities */
  @inline def implicitly[T](implicit e: T) = e    // for summoning implicit values from the nether world -- TODO: when dependent method types are on by default, give this result type `e.type`, so that inliner has better chance of knowing which method to inline in calls like `implicitly[MatchingStrategy[Option]].zero`
  /** @group utilities */
  @inline def locally[T](x: T): T  = x    // to communicate intent and avoid unmoored statements

  // assertions ---------------------------------------------------------

  /** Tests an expression, throwing an `AssertionError` if false.
   *  Calls to this method will not be generated if `-Xelide-below`
   *  is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assertion   the expression to test
   *  @group assertions
   */
  @elidable(ASSERTION)
  def assert(assertion: Boolean) {
    if (!assertion)
      throw new java.lang.AssertionError("assertion failed")
  }

  /** Tests an expression, throwing an `AssertionError` if false.
   *  Calls to this method will not be generated if `-Xelide-below`
   *  is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assertion   the expression to test
   *  @param message     a String to include in the failure message
   *  @group assertions
   */
  @elidable(ASSERTION) @inline
  final def assert(assertion: Boolean, message: => Any) {
    if (!assertion)
      throw new java.lang.AssertionError("assertion failed: "+ message)
  }

  /** Tests an expression, throwing an `AssertionError` if false.
   *  This method differs from assert only in the intent expressed:
   *  assert contains a predicate which needs to be proven, while
   *  assume contains an axiom for a static checker.  Calls to this method
   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assumption   the expression to test
   *  @group assertions
   */
  @elidable(ASSERTION)
  def assume(assumption: Boolean) {
    if (!assumption)
      throw new java.lang.AssertionError("assumption failed")
  }

  /** Tests an expression, throwing an `AssertionError` if false.
   *  This method differs from assert only in the intent expressed:
   *  assert contains a predicate which needs to be proven, while
   *  assume contains an axiom for a static checker.  Calls to this method
   *  will not be generated if `-Xelide-below` is greater than `ASSERTION`.
   *
   *  @see [[scala.annotation.elidable elidable]]
   *  @param assumption   the expression to test
   *  @param message      a String to include in the failure message
   *  @group assertions
   */
  @elidable(ASSERTION) @inline
  final def assume(assumption: Boolean, message: => Any) {
    if (!assumption)
      throw new java.lang.AssertionError("assumption failed: "+ message)
  }

  /** Tests an expression, throwing an `IllegalArgumentException` if false.
   *  This method is similar to `assert`, but blames the caller of the method
   *  for violating the condition.
   *
   *  @param requirement   the expression to test
   *  @group assertions
   */
  def require(requirement: Boolean) {
    if (!requirement)
      throw new IllegalArgumentException("requirement failed")
  }

  /** Tests an expression, throwing an `IllegalArgumentException` if false.
   *  This method is similar to `assert`, but blames the caller of the method
   *  for violating the condition.
   *
   *  @param requirement   the expression to test
   *  @param message       a String to include in the failure message
   *  @group assertions
   */
  @inline final def require(requirement: Boolean, message: => Any) {
    if (!requirement)
      throw new IllegalArgumentException("requirement failed: "+ message)
  }

  /** `???` can be used for marking methods that remain to be implemented.
   *  @throws NotImplementedError
   *  @group utilities
   */
  def ??? : Nothing = throw new NotImplementedError

  // tupling ------------------------------------------------------------

  @deprecated("use built-in tuple syntax or Tuple2 instead", "2.11.0")
  type Pair[+A, +B] = Tuple2[A, B]
  @deprecated("use built-in tuple syntax or Tuple2 instead", "2.11.0")
  object Pair {
    def apply[A, B](x: A, y: B) = Tuple2(x, y)
    def unapply[A, B](x: Tuple2[A, B]): Option[Tuple2[A, B]] = Some(x)
  }

  @deprecated("use built-in tuple syntax or Tuple3 instead", "2.11.0")
  type Triple[+A, +B, +C] = Tuple3[A, B, C]
  @deprecated("use built-in tuple syntax or Tuple3 instead", "2.11.0")
  object Triple {
    def apply[A, B, C](x: A, y: B, z: C) = Tuple3(x, y, z)
    def unapply[A, B, C](x: Tuple3[A, B, C]): Option[Tuple3[A, B, C]] = Some(x)
  }

  // implicit classes -----------------------------------------------------

  /** @group implicit-classes-any */
  implicit final class ArrowAssoc[A](private val self: A) extends AnyVal {
    @inline def -> [B](y: B): Tuple2[A, B] = Tuple2(self, y)
    def →[B](y: B): Tuple2[A, B] = ->(y)
  }

  /** @group implicit-classes-any */
  implicit final class Ensuring[A](private val self: A) extends AnyVal {
    def ensuring(cond: Boolean): A = { assert(cond); self }
    def ensuring(cond: Boolean, msg: => Any): A = { assert(cond, msg); self }
    def ensuring(cond: A => Boolean): A = { assert(cond(self)); self }
    def ensuring(cond: A => Boolean, msg: => Any): A = { assert(cond(self), msg); self }
  }

  /** @group implicit-classes-any */
  implicit final class StringFormat[A](private val self: A) extends AnyVal {
    /** Returns string formatted according to given `format` string.
     *  Format strings are as for `String.format`
     *  (@see java.lang.String.format).
     */
    @inline def formatted(fmtstr: String): String = fmtstr format self
  }

  // scala/bug#8229 retaining the pre 2.11 name for source compatibility in shadowing this implicit
  /** @group implicit-classes-any */
  implicit final class any2stringadd[A](private val self: A) extends AnyVal {
    def +(other: String): String = String.valueOf(self) + other
  }

  implicit final class RichException(private val self: Throwable) extends AnyVal {
    import scala.compat.Platform.EOL
    @deprecated("use Throwable#getStackTrace", "2.11.0") def getStackTraceString = self.getStackTrace().mkString("", EOL, EOL)
  }

  // Sadly we have to do `@deprecatedName(null, "2.12.0")` because
  // `@deprecatedName(since="2.12.0")` incurs a warning about
  //   Usage of named or default arguments transformed this annotation constructor call into a block.
  //   The corresponding AnnotationInfo will contain references to local values and default getters
  //   instead of the actual argument trees
  // and `@deprecatedName(Symbol("<none>"), "2.12.0")` crashes scalac with
  //   scala.reflect.internal.Symbols$CyclicReference: illegal cyclic reference involving object Symbol
  // in run/repl-no-imports-no-predef-power.scala.
  /** @group char-sequence-wrappers */
  final class SeqCharSequence(@deprecated("will be made private", "2.12.0") @deprecatedName(null, "2.12.0") val __sequenceOfChars: scala.collection.IndexedSeq[Char]) extends CharSequence {
    def length: Int                                     = __sequenceOfChars.length
    def charAt(index: Int): Char                        = __sequenceOfChars(index)
    def subSequence(start: Int, end: Int): CharSequence = new SeqCharSequence(__sequenceOfChars.slice(start, end))
    override def toString                               = __sequenceOfChars mkString ""
  }

  /** @group char-sequence-wrappers */
  def SeqCharSequence(sequenceOfChars: scala.collection.IndexedSeq[Char]): SeqCharSequence = new SeqCharSequence(sequenceOfChars)

  /** @group char-sequence-wrappers */
  @deprecated("use `java.nio.CharBuffer.wrap` instead", "2.12.13")
  final class ArrayCharSequence(@deprecated("will be made private", "2.12.0") @deprecatedName(null, "2.12.0") val __arrayOfChars: Array[Char]) extends CharSequence {
    def length: Int                                     = __arrayOfChars.length
    def charAt(index: Int): Char                        = __arrayOfChars(index)
    def subSequence(start: Int, end: Int): CharSequence = new runtime.ArrayCharSequence(__arrayOfChars, start, end)
    override def toString                               = __arrayOfChars mkString ""
  }

  /** @group char-sequence-wrappers */
  def ArrayCharSequence(arrayOfChars: Array[Char]): ArrayCharSequence = new ArrayCharSequence(arrayOfChars)

  implicit val StringCanBuildFrom: CanBuildFrom[String, Char, String] = new CanBuildFrom[String, Char, String] {
    def apply(from: String) = apply()
    def apply()             = mutable.StringBuilder.newBuilder
  }

  /** @group conversions-string */
  @inline implicit def augmentString(x: String): StringOps = new StringOps(x)
  /** @group conversions-string */
  @inline implicit def unaugmentString(x: StringOps): String = x.repr

  // printing -----------------------------------------------------------

  /** Prints an object to `out` using its `toString` method.
   *
   *  @param x the object to print; may be null.
   *  @group console-output
   */
  def print(x: Any) = Console.print(x)

  /** Prints a newline character on the default output.
   *  @group console-output
   */
  def println() = Console.println()

  /** Prints out an object to the default output, followed by a newline character.
   *
   *  @param x the object to print.
   *  @group console-output
   */
  def println(x: Any) = Console.println(x)

  /** Prints its arguments as a formatted string to the default output,
   *  based on a string pattern (in a fashion similar to printf in C).
   *
   *  The interpretation of the formatting patterns is described in
   *  [[java.util.Formatter]].
   *
   *  Consider using the [[scala.StringContext.f f interpolator]] as more type safe and idiomatic.
   *
   *  @param text the pattern for formatting the arguments.
   *  @param args the arguments used to instantiating the pattern.
   *  @throws java.lang.IllegalArgumentException if there was a problem with the format string or arguments
   *
   *  @see [[scala.StringContext.f StringContext.f]]
   *  @group console-output
   */
  def printf(text: String, xs: Any*) = Console.print(text.format(xs: _*))

  // views --------------------------------------------------------------

  implicit def tuple2ToZippedOps[T1, T2](x: (T1, T2))                           = new runtime.Tuple2Zipped.Ops(x)
  implicit def tuple3ToZippedOps[T1, T2, T3](x: (T1, T2, T3))                   = new runtime.Tuple3Zipped.Ops(x)

  implicit def genericArrayOps[T](xs: Array[T]): ArrayOps[T] = (xs match {
    case x: Array[AnyRef]  => refArrayOps[AnyRef](x)
    case x: Array[Boolean] => booleanArrayOps(x)
    case x: Array[Byte]    => byteArrayOps(x)
    case x: Array[Char]    => charArrayOps(x)
    case x: Array[Double]  => doubleArrayOps(x)
    case x: Array[Float]   => floatArrayOps(x)
    case x: Array[Int]     => intArrayOps(x)
    case x: Array[Long]    => longArrayOps(x)
    case x: Array[Short]   => shortArrayOps(x)
    case x: Array[Unit]    => unitArrayOps(x)
    case null              => null
  }).asInstanceOf[ArrayOps[T]]

  implicit def booleanArrayOps(xs: Array[Boolean]): ArrayOps.ofBoolean   = new ArrayOps.ofBoolean(xs)
  implicit def byteArrayOps(xs: Array[Byte]): ArrayOps.ofByte            = new ArrayOps.ofByte(xs)
  implicit def charArrayOps(xs: Array[Char]): ArrayOps.ofChar            = new ArrayOps.ofChar(xs)
  implicit def doubleArrayOps(xs: Array[Double]): ArrayOps.ofDouble      = new ArrayOps.ofDouble(xs)
  implicit def floatArrayOps(xs: Array[Float]): ArrayOps.ofFloat         = new ArrayOps.ofFloat(xs)
  implicit def intArrayOps(xs: Array[Int]): ArrayOps.ofInt               = new ArrayOps.ofInt(xs)
  implicit def longArrayOps(xs: Array[Long]): ArrayOps.ofLong            = new ArrayOps.ofLong(xs)
  implicit def refArrayOps[T <: AnyRef](xs: Array[T]): ArrayOps.ofRef[T] = new ArrayOps.ofRef[T](xs)
  implicit def shortArrayOps(xs: Array[Short]): ArrayOps.ofShort         = new ArrayOps.ofShort(xs)
  implicit def unitArrayOps(xs: Array[Unit]): ArrayOps.ofUnit            = new ArrayOps.ofUnit(xs)

  // "Autoboxing" and "Autounboxing" ---------------------------------------------------

  /** @group conversions-anyval-to-java */
  implicit def byte2Byte(x: Byte): java.lang.Byte             = x.asInstanceOf[java.lang.Byte]
  /** @group conversions-anyval-to-java */
  implicit def short2Short(x: Short): java.lang.Short         = x.asInstanceOf[java.lang.Short]
  /** @group conversions-anyval-to-java */
  implicit def char2Character(x: Char): java.lang.Character   = x.asInstanceOf[java.lang.Character]
  /** @group conversions-anyval-to-java */
  implicit def int2Integer(x: Int): java.lang.Integer         = x.asInstanceOf[java.lang.Integer]
  /** @group conversions-anyval-to-java */
  implicit def long2Long(x: Long): java.lang.Long             = x.asInstanceOf[java.lang.Long]
  /** @group conversions-anyval-to-java */
  implicit def float2Float(x: Float): java.lang.Float         = x.asInstanceOf[java.lang.Float]
  /** @group conversions-anyval-to-java */
  implicit def double2Double(x: Double): java.lang.Double     = x.asInstanceOf[java.lang.Double]
  /** @group conversions-anyval-to-java */
  implicit def boolean2Boolean(x: Boolean): java.lang.Boolean = x.asInstanceOf[java.lang.Boolean]

  /** @group conversions-java-to-anyval */
  implicit def Byte2byte(x: java.lang.Byte): Byte             = x.asInstanceOf[Byte]
  /** @group conversions-java-to-anyval */
  implicit def Short2short(x: java.lang.Short): Short         = x.asInstanceOf[Short]
  /** @group conversions-java-to-anyval */
  implicit def Character2char(x: java.lang.Character): Char   = x.asInstanceOf[Char]
  /** @group conversions-java-to-anyval */
  implicit def Integer2int(x: java.lang.Integer): Int         = x.asInstanceOf[Int]
  /** @group conversions-java-to-anyval */
  implicit def Long2long(x: java.lang.Long): Long             = x.asInstanceOf[Long]
  /** @group conversions-java-to-anyval */
  implicit def Float2float(x: java.lang.Float): Float         = x.asInstanceOf[Float]
  /** @group conversions-java-to-anyval */
  implicit def Double2double(x: java.lang.Double): Double     = x.asInstanceOf[Double]
  /** @group conversions-java-to-anyval */
  implicit def Boolean2boolean(x: java.lang.Boolean): Boolean = x.asInstanceOf[Boolean]

  // Type Constraints --------------------------------------------------------------

  /**
   * An instance of `A <:< B` witnesses that `A` is a subtype of `B`.
   * Requiring an implicit argument of the type `A <:< B` encodes
   * the generalized constraint `A <: B`.
   *
   * @note we need a new type constructor `<:<` and evidence `conforms`,
   * as reusing `Function1` and `identity` leads to ambiguities in
   * case of type errors (`any2stringadd` is inferred)
   *
   * To constrain any abstract type T that's in scope in a method's
   * argument list (not just the method's own type parameters) simply
   * add an implicit argument of type `T <:< U`, where `U` is the required
   * upper bound; or for lower-bounds, use: `L <:< T`, where `L` is the
   * required lower bound.
   *
   * In part contributed by Jason Zaugg.
   * @group type-constraints
   */
  @implicitNotFound(msg = "Cannot prove that ${From} <:< ${To}.")
  sealed abstract class <:<[-From, +To] extends (From => To) with Serializable
  private[this] final val singleton_<:< = new <:<[Any,Any] { def apply(x: Any): Any = x }
  // The dollar prefix is to dodge accidental shadowing of this method
  // by a user-defined method of the same name (scala/bug#7788).
  // The collections rely on this method.
  /** @group type-constraints */
  implicit def $conforms[A]: A <:< A = singleton_<:<.asInstanceOf[A <:< A]

  @deprecated("use `implicitly[T <:< U]` or `identity` instead.", "2.11.0")
  def conforms[A]: A <:< A = $conforms[A]

  /** An instance of `A =:= B` witnesses that the types `A` and `B` are equal.
   *
   * @see `<:<` for expressing subtyping constraints
   * @group type-constraints
   */
  @implicitNotFound(msg = "Cannot prove that ${From} =:= ${To}.")
  sealed abstract class =:=[From, To] extends (From => To) with Serializable
  private[this] final val singleton_=:= = new =:=[Any,Any] { def apply(x: Any): Any = x }
  /** @group type-constraints */
  object =:= {
     implicit def tpEquals[A]: A =:= A = singleton_=:=.asInstanceOf[A =:= A]
  }

  /** A type for which there is always an implicit value.
   *  @see [[scala.Array$]], method `fallbackCanBuildFrom`
   */
  class DummyImplicit

  object DummyImplicit {

    /** An implicit value yielding a `DummyImplicit`.
     *   @see [[scala.Array$]], method `fallbackCanBuildFrom`
     */
    implicit def dummyImplicit: DummyImplicit = new DummyImplicit
  }
}

private[scala] trait DeprecatedPredef {
  self: Predef.type =>

  // Deprecated stubs for any who may have been calling these methods directly.
  @deprecated("use `ArrowAssoc`", "2.11.0") def any2ArrowAssoc[A](x: A): ArrowAssoc[A]                                      = new ArrowAssoc(x)
  @deprecated("use `Ensuring`", "2.11.0") def any2Ensuring[A](x: A): Ensuring[A]                                            = new Ensuring(x)
  @deprecated("use `StringFormat`", "2.11.0") def any2stringfmt(x: Any): StringFormat[Any]                                  = new StringFormat(x)
  @deprecated("use `Throwable` directly", "2.11.0") def exceptionWrapper(exc: Throwable)                                    = new RichException(exc)
  @deprecated("use `SeqCharSequence`", "2.11.0") def seqToCharSequence(xs: scala.collection.IndexedSeq[Char]): CharSequence = new SeqCharSequence(xs)
  @deprecated("use `java.nio.CharBuffer.wrap`", "2.11.0") def arrayToCharSequence(xs: Array[Char]): CharSequence = new ArrayCharSequence(xs)

  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLine(): String                 = StdIn.readLine()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLine(text: String, args: Any*) = StdIn.readLine(text, args: _*)
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readBoolean()                      = StdIn.readBoolean()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readByte()                         = StdIn.readByte()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readShort()                        = StdIn.readShort()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readChar()                         = StdIn.readChar()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readInt()                          = StdIn.readInt()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readLong()                         = StdIn.readLong()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readFloat()                        = StdIn.readFloat()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readDouble()                       = StdIn.readDouble()
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf(format: String)              = StdIn.readf(format)
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf1(format: String)             = StdIn.readf1(format)
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf2(format: String)             = StdIn.readf2(format)
  @deprecated("use the method in `scala.io.StdIn`", "2.11.0") def readf3(format: String)             = StdIn.readf3(format)
}

/** The `LowPriorityImplicits` class provides implicit values that
*  are valid in all Scala compilation units without explicit qualification,
*  but that are partially overridden by higher-priority conversions in object
*  `Predef`.
*
*  @author  Martin Odersky
*  @since 2.8
*/
// scala/bug#7335 Parents of Predef are defined in the same compilation unit to avoid
// cyclic reference errors compiling the standard library *without* a previously
// compiled copy on the classpath.
private[scala] abstract class LowPriorityImplicits {
  import mutable.WrappedArray
  import immutable.WrappedString

  /** We prefer the java.lang.* boxed types to these wrappers in
   *  any potential conflicts.  Conflicts do exist because the wrappers
   *  need to implement ScalaNumber in order to have a symmetric equals
   *  method, but that implies implementing java.lang.Number as well.
   *
   *  Note - these are inlined because they are value classes, but
   *  the call to xxxWrapper is not eliminated even though it does nothing.
   *  Even inlined, every call site does a no-op retrieval of Predef's MODULE$
   *  because maybe loading Predef has side effects!
   */
  @inline implicit def byteWrapper(x: Byte)       = new runtime.RichByte(x)
  @inline implicit def shortWrapper(x: Short)     = new runtime.RichShort(x)
  @inline implicit def intWrapper(x: Int)         = new runtime.RichInt(x)
  @inline implicit def charWrapper(c: Char)       = new runtime.RichChar(c)
  @inline implicit def longWrapper(x: Long)       = new runtime.RichLong(x)
  @inline implicit def floatWrapper(x: Float)     = new runtime.RichFloat(x)
  @inline implicit def doubleWrapper(x: Double)   = new runtime.RichDouble(x)
  @inline implicit def booleanWrapper(x: Boolean) = new runtime.RichBoolean(x)

  /** @group conversions-array-to-wrapped-array */
  implicit def genericWrapArray[T](xs: Array[T]): WrappedArray[T] =
    if (xs eq null) null
    else WrappedArray.make(xs)

  // Since the JVM thinks arrays are covariant, one 0-length Array[AnyRef]
  // is as good as another for all T <: AnyRef.  Instead of creating 100,000,000
  // unique ones by way of this implicit, let's share one.
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapRefArray[T <: AnyRef](xs: Array[T]): WrappedArray[T] = {
    if (xs eq null) null
    else if (xs.length == 0) WrappedArray.empty[T]
    else new WrappedArray.ofRef[T](xs)
  }

  /** @group conversions-array-to-wrapped-array */
  implicit def wrapIntArray(xs: Array[Int]): WrappedArray[Int] = if (xs ne null) new WrappedArray.ofInt(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapDoubleArray(xs: Array[Double]): WrappedArray[Double] = if (xs ne null) new WrappedArray.ofDouble(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapLongArray(xs: Array[Long]): WrappedArray[Long] = if (xs ne null) new WrappedArray.ofLong(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapFloatArray(xs: Array[Float]): WrappedArray[Float] = if (xs ne null) new WrappedArray.ofFloat(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapCharArray(xs: Array[Char]): WrappedArray[Char] = if (xs ne null) new WrappedArray.ofChar(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapByteArray(xs: Array[Byte]): WrappedArray[Byte] = if (xs ne null) new WrappedArray.ofByte(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapShortArray(xs: Array[Short]): WrappedArray[Short] = if (xs ne null) new WrappedArray.ofShort(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapBooleanArray(xs: Array[Boolean]): WrappedArray[Boolean] = if (xs ne null) new WrappedArray.ofBoolean(xs) else null
  /** @group conversions-array-to-wrapped-array */
  implicit def wrapUnitArray(xs: Array[Unit]): WrappedArray[Unit] = if (xs ne null) new WrappedArray.ofUnit(xs) else null

  /** @group conversions-string */
  implicit def wrapString(s: String): WrappedString = if (s ne null) new WrappedString(s) else null
  /** @group conversions-string */
  implicit def unwrapString(ws: WrappedString): String = if (ws ne null) ws.self else null

  implicit def fallbackStringCanBuildFrom[T]: CanBuildFrom[String, T, immutable.IndexedSeq[T]] =
    new CanBuildFrom[String, T, immutable.IndexedSeq[T]] {
      def apply(from: String) = immutable.IndexedSeq.newBuilder[T]
      def apply() = immutable.IndexedSeq.newBuilder[T]
    }
}



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:23:38 PM scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Mar 27, 2021 6:23:38 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: 
  unexpected tree: class scala.reflect.internal.Trees$Template
Int
     while compiling: file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala
        during phase: globalPhase=<no phase>, enteringPhase=parser
     library version: version 2.12.13
    compiler version: version 2.12.13
  reconstructed args: -classpath /Users/benomac/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.12.13/scala-library-2.12.13.jar -Ymacro-expand:discard -Ycache-plugin-class-loader:last-modified -Ypresentation-any-thread

  last tree to typer: Template
       tree position: line 53 of file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala
              symbol: <none>
   symbol definition: <none> (a NoSymbol)
      symbol package: <none>
       symbol owners: 
           call site: <none> in <none>

== Source file context for tree position ==

    50       } yield (x -> i)).toMap
    51     } 
    52 
    53   def total (validItems: String, products: Map[Char, Price]): Int {
    54     println("Total " + {
    55     for ((key,value) <- createToBuyMap(valid)) yield {
    56         // add function to check  if item is valid 
scala.reflect.internal.FatalError: 
  unexpected tree: class scala.reflect.internal.Trees$Template
Int
     while compiling: file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala
        during phase: globalPhase=<no phase>, enteringPhase=parser
     library version: version 2.12.13
    compiler version: version 2.12.13
  reconstructed args: -classpath /Users/benomac/Library/Caches/Coursier/v1/https/repo1.maven.org/maven2/org/scala-lang/scala-library/2.12.13/scala-library-2.12.13.jar -Ymacro-expand:discard -Ycache-plugin-class-loader:last-modified -Ypresentation-any-thread

  last tree to typer: Template
       tree position: line 53 of file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala
              symbol: <none>
   symbol definition: <none> (a NoSymbol)
      symbol package: <none>
       symbol owners: 
           call site: <none> in <none>

== Source file context for tree position ==

    50       } yield (x -> i)).toMap
    51     } 
    52 
    53   def total (validItems: String, products: Map[Char, Price]): Int {
    54     println("Total " + {
    55     for ((key,value) <- createToBuyMap(valid)) yield {
    56         // add function to check  if item is valid 
	at scala.reflect.internal.Reporting.abort(Reporting.scala:69)
	at scala.reflect.internal.Reporting.abort$(Reporting.scala:65)
	at scala.reflect.internal.SymbolTable.abort(SymbolTable.scala:28)
	at scala.tools.nsc.typechecker.Typers$Typer.typedOutsidePatternMode$1(Typers.scala:5727)
	at scala.tools.nsc.typechecker.Typers$Typer.typed1(Typers.scala:5744)
	at scala.tools.nsc.typechecker.Typers$Typer.typed(Typers.scala:5780)
	at scala.tools.nsc.typechecker.Typers$Typer.typedQualifier(Typers.scala:5864)
	at scala.meta.internal.pc.PcDefinitionProvider.definitionTypedTreeAt(PcDefinitionProvider.scala:111)
	at scala.meta.internal.pc.PcDefinitionProvider.definition(PcDefinitionProvider.scala:24)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:23:48 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:23:56 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:24:16 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): Int = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
[0m2021.03.27 18:24:40 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
[0m2021.03.27 18:24:59 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
[0m2021.03.27 18:25:22 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
something's wrong: no file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala in Map[Char,Main.Price]RangePosition(file:///Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala, 1552, 1552, 1568)


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
[0m2021.03.27 18:25:31 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def total (validItems: String, products: Map[Char, Price]): String = {
    
    for ((key,value) <- createToBuyMap(validItems)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    
  }
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total(valid, prices)

//end
}
[0m2021.03.27 18:27:11 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:27:22 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid)
  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:28:17 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid + 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid + 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid + 1)
  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:28:23 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:28:45 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:31:11 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:31:37 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala
package collection

import generic._
import mutable.{ Builder, MapBuilder }
import scala.annotation.migration
import parallel.ParMap

/** A template trait for maps, which associate keys with values.
 *
 *  $mapNote
 *  $mapTags
 *  @since 2.8
 *
 *  @define mapNote
 *    '''Implementation note:'''
 *    This trait provides most of the operations of a `Map` independently of its representation.
 *    It is typically inherited by concrete implementations of maps.
 *
 *    To implement a concrete map, you need to provide implementations of the
 *    following methods:
 *    {{{
 *       def get(key: K): Option[V]
 *       def iterator: Iterator[(K, V)]
 *       def + [V1 >: V](kv: (K, V1)): This
 *       def -(key: K): This
 *    }}}
 *    If you wish that methods like `take`, `drop`, `filter` also return the same kind of map
 *    you should also override:
 *    {{{
 *       def empty: This
 *    }}}
 *    It is also good idea to override methods `foreach` and
 *    `size` for efficiency.
 *
 *  @define mapTags
 *  @tparam K    the type of the keys.
 *  @tparam V    the type of associated values.
 *  @tparam This the type of the map itself.
 *
 *  @author  Martin Odersky
 *
 *  @define coll map
 *  @define Coll Map
 *  @define willNotTerminateInf
 *  @define mayNotTerminateInf
 */
trait MapLike[K, +V, +This <: MapLike[K, V, This] with Map[K, V]]
  extends PartialFunction[K, V]
     with IterableLike[(K, V), This]
     with GenMapLike[K, V, This]
     with Subtractable[K, This]
     with Parallelizable[(K, V), ParMap[K, V]]
{
self =>

  /** The empty map of the same type as this map
   *   @return   an empty map of type `This`.
   */
  def empty: This

  /** A common implementation of `newBuilder` for all maps in terms of `empty`.
   *  Overridden for mutable maps in `mutable.MapLike`.
   */
  override protected[this] def newBuilder: Builder[(K, V), This] = new MapBuilder[K, V, This](empty)

  /** Optionally returns the value associated with a key.
   *
   *  @param  key    the key value
   *  @return an option value containing the value associated with `key` in this map,
   *          or `None` if none exists.
   */
  def get(key: K): Option[V]

  /** Creates a new iterator over all key/value pairs of this map
   *
   *  @return the new iterator
   */
  def iterator: Iterator[(K, V)]

  /** Adds a key/value pair to this map, returning a new map.
   *  @param    kv the key/value pair
   *  @tparam   V1 the type of the value in the key/value pair.
   *  @return   a new map with the new binding added to this map
   *
   *  @usecase  def + (kv: (K, V)): Map[K, V]
   *    @inheritdoc
   */
  def + [V1 >: V] (kv: (K, V1)): Map[K, V1]

  /** Removes a key from this map, returning a new map.
   *  @param    key the key to be removed
   *  @return   a new map without a binding for `key`
   *
   *  @usecase  def - (key: K): Map[K, V]
   *    @inheritdoc
   */
  def - (key: K): This

  /** Tests whether the map is empty.
   *
   *  @return `true` if the map does not contain any key/value binding, `false` otherwise.
   */
  override def isEmpty: Boolean = size == 0

  /**  Returns the value associated with a key, or a default value if the key is not contained in the map.
   *   @param   key      the key.
   *   @param   default  a computation that yields a default value in case no binding for `key` is
   *                     found in the map.
   *   @tparam  V1       the result type of the default computation.
   *   @return  the value associated with `key` if it exists,
   *            otherwise the result of the `default` computation.
   *
   *   @usecase def getOrElse(key: K, default: => V): V
   *     @inheritdoc
   */
  def getOrElse[V1 >: V](key: K, default: => V1): V1 = get(key) match {
    case Some(v) => v
    case None => default
  }

  /** Retrieves the value which is associated with the given key. This
   *  method invokes the `default` method of the map if there is no mapping
   *  from the given key to a value. Unless overridden, the `default` method throws a
   *  `NoSuchElementException`.
   *
   *  @param  key the key
   *  @return     the value associated with the given key, or the result of the
   *              map's `default` method, if none exists.
   */
  def apply(key: K): V = get(key) match {
    case None => default(key)
    case Some(value) => value
  }

  /** Tests whether this map contains a binding for a key.
   *
   *  @param key the key
   *  @return    `true` if there is a binding for `key` in this map, `false` otherwise.
   */
  def contains(key: K): Boolean = get(key).isDefined

  /** Tests whether this map contains a binding for a key. This method,
   *  which implements an abstract method of trait `PartialFunction`,
   *  is equivalent to `contains`.
   *
   *  @param key the key
   *  @return    `true` if there is a binding for `key` in this map, `false` otherwise.
   */
  def isDefinedAt(key: K) = contains(key)

  override /*PartialFunction*/
  def applyOrElse[K1 <: K, V1 >: V](x: K1, default: K1 => V1): V1 =
    getOrElse(x, default(x))

  /** Collects all keys of this map in a set.
   * @return  a set containing all keys of this map.
   */
  def keySet: Set[K] = new DefaultKeySet

  /** The implementation class of the set returned by `keySet`.
   */
  protected class DefaultKeySet extends AbstractSet[K] with Set[K] with Serializable {
    def contains(key : K) = self.contains(key)
    def iterator = keysIterator
    def + (elem: K): Set[K] = (Set[K]() ++ this + elem).asInstanceOf[Set[K]] // !!! concrete overrides abstract problem
    def - (elem: K): Set[K] = (Set[K]() ++ this - elem).asInstanceOf[Set[K]] // !!! concrete overrides abstract problem
    override def size = self.size
    override def foreach[U](f: K => U) = self.keysIterator foreach f
  }

  /** Creates an iterator for all keys.
   *
   *  @return an iterator over all keys.
   */
  def keysIterator: Iterator[K] = new AbstractIterator[K] {
    val iter = self.iterator
    def hasNext = iter.hasNext
    def next() = iter.next()._1
  }

  /** Collects all keys of this map in an iterable collection.
   *
   *  @return the keys of this map as an iterable.
   */
  @migration("`keys` returns `Iterable[K]` rather than `Iterator[K]`.", "2.8.0")
  def keys: Iterable[K] = keySet

  /** Collects all values of this map in an iterable collection.
   *
   *  @return the values of this map as an iterable.
   */
  @migration("`values` returns `Iterable[V]` rather than `Iterator[V]`.", "2.8.0")
  def values: Iterable[V] = new DefaultValuesIterable

  /** The implementation class of the iterable returned by `values`.
   */
  protected class DefaultValuesIterable extends AbstractIterable[V] with Iterable[V] with Serializable {
    def iterator = valuesIterator
    override def size = self.size
    override def foreach[U](f: V => U) = self.valuesIterator foreach f
  }

  /** Creates an iterator for all values in this map.
   *
   *  @return an iterator over all values that are associated with some key in this map.
   */
  def valuesIterator: Iterator[V] = new AbstractIterator[V] {
    val iter = self.iterator
    def hasNext = iter.hasNext
    def next() = iter.next()._2
  }

  /** Defines the default value computation for the map,
   *  returned when a key is not found
   *  The method implemented here throws an exception,
   *  but it might be overridden in subclasses.
   *
   *  @param key the given key value for which a binding is missing.
   *  @throws NoSuchElementException
   */
  def default(key: K): V =
    throw new NoSuchElementException("key not found: " + key)

  protected class FilteredKeys(p: K => Boolean) extends AbstractMap[K, V] with DefaultMap[K, V] {
    override def foreach[U](f: ((K, V)) => U): Unit = for (kv <- self) if (p(kv._1)) f(kv)
    def iterator = self.iterator.filter(kv => p(kv._1))
    override def contains(key: K) = p(key) && self.contains(key)
    def get(key: K) = if (!p(key)) None else self.get(key)
  }

  /** Filters this map by retaining only keys satisfying a predicate.
   *
   *  '''Note''': the predicate must accept any key of type `K`, not just those already
   *  present in the map, as the predicate is tested before the underlying map is queried.
   *
   *  @param  p   the predicate used to test keys
   *  @return an immutable map consisting only of those key value pairs of this map where the key satisfies
   *          the predicate `p`. The resulting map wraps the original map without copying any elements.
   */
  def filterKeys(p: K => Boolean): Map[K, V] = new FilteredKeys(p)

  protected class MappedValues[W](f: V => W) extends AbstractMap[K, W] with DefaultMap[K, W] {
    override def foreach[U](g: ((K, W)) => U): Unit = for ((k, v) <- self) g((k, f(v)))
    def iterator = for ((k, v) <- self.iterator) yield (k, f(v))
    override def size = self.size
    override def contains(key: K) = self.contains(key)
    def get(key: K) = self.get(key).map(f)
  }

  /** Transforms this map by applying a function to every retrieved value.
   *  @param  f   the function used to transform values of this map.
   *  @return a map view which maps every key of this map
   *          to `f(this(key))`. The resulting map wraps the original map without copying any elements.
   */
  def mapValues[W](f: V => W): Map[K, W] = new MappedValues(f)

  // The following 5 operations (updated, two times +, two times ++) should really be
  // generic, returning This[V]. We need better covariance support to express that though.
  // So right now we do the brute force approach of code duplication.

  /** Creates a new map obtained by updating this map with a given key/value pair.
   *  @param    key the key
   *  @param    value the value
   *  @tparam   V1 the type of the added value
   *  @return   A new map with the new key/value mapping added to this map.
   *
   *  @usecase  def updated(key: K, value: V): Map[K, V]
   *    @inheritdoc
   */
  def updated [V1 >: V](key: K, value: V1): Map[K, V1] = this + ((key, value))

  /** Adds key/value pairs to this map, returning a new map.
   *
   *  This method takes two or more key/value pairs. Another overloaded
   *  variant of this method handles the case where a single key/value pair is
   *  added.
   *  @param    kv1 the first key/value pair
   *  @param    kv2 the second key/value pair
   *  @param    kvs the remaining key/value pairs
   *  @tparam   V1  the type of the added values
   *  @return   a new map with the given bindings added to this map
   *
   *  @usecase  def + (kvs: (K, V)*): Map[K, V]
   *    @inheritdoc
   *    @param    kvs the key/value pairs
   */
  def + [V1 >: V] (kv1: (K, V1), kv2: (K, V1), kvs: (K, V1) *): Map[K, V1] =
    this + kv1 + kv2 ++ kvs

  /** Adds all key/value pairs in a traversable collection to this map, returning a new map.
   *
   *  @param    xs  the collection containing the added key/value pairs
   *  @tparam   V1  the type of the added values
   *  @return   a new map with the given bindings added to this map
   *
   *  @usecase  def ++ (xs: Traversable[(K, V)]): Map[K, V]
   *    @inheritdoc
   */
  def ++[V1 >: V](xs: GenTraversableOnce[(K, V1)]): Map[K, V1] =
    ((repr: Map[K, V1]) /: xs.seq) (_ + _)

  /** Returns a new map obtained by removing all key/value pairs for which the predicate
   *  `p` returns `true`.
   *
   *  '''Note:'''    This method works by successively removing elements for which the
   *           predicate is true from this set.
   *           If removal is slow, or you expect that most elements of the set
   *           will be removed, you might consider using `filter`
   *           with a negated predicate instead.
   *  @param p    A predicate over key-value pairs
   *  @return     A new map containing elements not satisfying the predicate.
   */
  override def filterNot(p: ((K, V)) => Boolean): This = {
    var res: This = repr
    for (kv <- this)
      if (p(kv)) res = (res - kv._1).asInstanceOf[This] // !!! concrete overrides abstract problem
    res
  }

  override def toSeq: Seq[(K, V)] = {
    if (isEmpty) Vector.empty[(K, V)]
    else {
      // Default appropriate for immutable collections; mutable collections override this
      val vb = Vector.newBuilder[(K, V)]
      foreach(vb += _)
      vb.result
    }
  }

  override def toBuffer[E >: (K, V)]: mutable.Buffer[E] = {
    val result = new mutable.ArrayBuffer[E](size)
    // Faster to let the map iterate itself than to defer through copyToBuffer
    foreach(result += _)
    result
  }

  protected[this] override def parCombiner = ParMap.newCombiner[K, V]

  /** Appends all bindings of this map to a string builder using start, end, and separator strings.
   *  The written text begins with the string `start` and ends with the string
   *  `end`. Inside, the string representations of all bindings of this map
   *  in the form of `key -> value` are separated by the string `sep`.
   *
   *  @param b     the builder to which strings are appended.
   *  @param start the starting string.
   *  @param sep   the separator string.
   *  @param end   the ending string.
   *  @return      the string builder `b` to which elements were appended.
   */
  override def addString(b: StringBuilder, start: String, sep: String, end: String): StringBuilder =
    this.iterator.map { case (k, v) => k+" -> "+v }.addString(b, start, sep, end)

  /** Defines the prefix of this object's `toString` representation.
   *  @return  a string representation which starts the result of `toString` applied to this $coll.
   *           Unless overridden in subclasses, the string prefix of every map is `"Map"`.
   */
  override def stringPrefix: String = "Map"

  override /*PartialFunction*/
  def toString = super[IterableLike].toString

}



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {

  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:31:43 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:32:44 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
  }
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:32:50 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:32:50 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:02 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:03 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:03 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:03 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:04 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:04 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:04 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:05 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:05 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:06 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:06 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:06 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:07 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:07 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:07 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:08 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:08 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:09 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:09 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:09 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:09 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:11 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:12 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:12 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

  def toital (vals: String, products: Price): String = {
    println("Total " + {
    for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, products(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, products(key))
        }
      }
    }.sum)
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
  
  //Get the total cost   
  total

//end
}
Mar 27, 2021 6:33:13 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:89: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.27 18:33:17 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)
    println(valid += 1)
  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:33:22 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
}
[0m2021.03.27 18:34:46 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)

    
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:35:04 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)

    
}
[0m2021.03.27 18:35:55 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    // def total = 
    // println("Total " + {
    // for ((key,value) <- createToBuyMap(valid)) yield {
    //     // add function to check  if item is valid 
    //     if(prices(key).numForDeal == 0) {
    //       (priceWhenItemHasNoDealValues(value, prices(key)))
    //     } else {
    //       priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
    //     }
    //   }
    // }.sum)

    
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  // def total = 
  //   println("Total " + {
  //   for ((key,value) <- createToBuyMap(valid)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prices(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
  //       }
  //     }
  //   }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:36:03 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    // def total = 
    // println("Total " + {
    // for ((key,value) <- createToBuyMap(valid)) yield {
    //     // add function to check  if item is valid 
    //     if(prices(key).numForDeal == 0) {
    //       (priceWhenItemHasNoDealValues(value, prices(key)))
    //     } else {
    //       priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
    //     }
    //   }
    // }.sum)

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    // def total = 
    // println("Total " + {
    // for ((key,value) <- createToBuyMap(valid)) yield {
    //     // add function to check  if item is valid 
    //     if(prices(key).numForDeal == 0) {
    //       (priceWhenItemHasNoDealValues(value, prices(key)))
    //     } else {
    //       priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
    //     }
    //   }
    // }.sum)

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    // def total = 
    // println("Total " + {
    // for ((key,value) <- createToBuyMap(valid)) yield {
    //     // add function to check  if item is valid 
    //     if(prices(key).numForDeal == 0) {
    //       (priceWhenItemHasNoDealValues(value, prices(key)))
    //     } else {
    //       priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
    //     }
    //   }
    // }.sum)

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    // def total = 
    // println("Total " + {
    // for ((key,value) <- createToBuyMap(valid)) yield {
    //     // add function to check  if item is valid 
    //     if(prices(key).numForDeal == 0) {
    //       (priceWhenItemHasNoDealValues(value, prices(key)))
    //     } else {
    //       priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
    //     }
    //   }
    // }.sum)

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    // def total = 
    // println("Total " + {
    // for ((key,value) <- createToBuyMap(valid)) yield {
    //     // add function to check  if item is valid 
    //     if(prices(key).numForDeal == 0) {
    //       (priceWhenItemHasNoDealValues(value, prices(key)))
    //     } else {
    //       priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
    //     }
    //   }
    // }.sum)

    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    // def total = 
    // println("Total " + {
    // for ((key,value) <- createToBuyMap(valid)) yield {
    //     // add function to check  if item is valid 
    //     if(prices(key).numForDeal == 0) {
    //       (priceWhenItemHasNoDealValues(value, prices(key)))
    //     } else {
    //       priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
    //     }
    //   }
    // }.sum)

    
}
[0m2021.03.27 18:36:20 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:36:23 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 18:36:32 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    println("Total " + {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }.sum)
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 19:24:10 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 7:24:10 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 7:24:15 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 7:24:16 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 7:24:20 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 7:24:23 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 7:24:24 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)



object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
Mar 27, 2021 7:24:24 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FMain.scala:79: error: } expected but end of file found

^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.syntaxErrorExpected(ScalametaParser.scala:835)
	at scala.meta.internal.parsers.ScalametaParser.accept(ScalametaParser.scala:841)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:714)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.27 19:24:24 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  total

//end
}
[0m2021.03.27 19:24:36 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total = 
    {
    for ((key,value) <- createToBuyMap(valid)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total)

//end
}
[0m2021.03.27 19:25:42 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prices(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prices(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}
[0m2021.03.27 19:26:10 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Price) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Price) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Price) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid))

//end
}
[0m2021.03.27 19:26:25 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Price) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Price) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Price) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Price) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Price) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Price) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:27:11 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:27:25 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = string {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = string {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = string {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = string {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:27:29 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = String {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = String {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = String {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = String {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = String {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = String {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = String {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]) = String {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:27:42 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String =  {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String =  {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:27:43 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:28:05 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:28:16 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toString
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toString
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toString
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toString
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toString
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toString
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toString
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:28:32 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:29:03 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "total" + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "total" + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "total" + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "total" + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "total" + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "total" + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "total" + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "total" + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "total" + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:29:17 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
Mar 27, 2021 7:30:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 57 is not a valid line number, allowed [0..50]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 57 is not a valid line number, allowed [0..50]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.IllegalArgumentException: 57 is not a valid line number, allowed [0..50]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:61)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

Mar 27, 2021 7:30:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 57 is not a valid line number, allowed [0..50]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 57 is not a valid line number, allowed [0..50]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2088)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.IllegalArgumentException: 57 is not a valid line number, allowed [0..50]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:61)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}


object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  //Get the price for any deals made
  def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:30:37 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import yoots._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
// object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
//     def priceForDeals (count: Int, products: Price): Int = {
//     (count / products.numForDeal) * products.priceForDeal
//   }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

    
// }
[0m2021.03.27 19:30:44 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
import yoots._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:30:55 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
object Yoots {
    
//     case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

//   //Map of classes for item prices
//   val prices = Map('a' -> Price(50, 3, 130), 
//                     'b' -> Price(30, 2, 45), 
//                     'c' -> Price(20, 0, 0), 
//                     'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
[0m2021.03.27 19:31:06 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
[0m2021.03.27 19:31:32 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
  //   case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:31:34 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
object Yoots {
    
  //   case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
object Yoots {
    
  //   case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
object Yoots {
    
  //   case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
[0m2021.03.27 19:31:57 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
import Yoots._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import Yoots._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import Yoots._

object Main extends App {

  //make case class
  case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:32:07 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
//   def priceForNoDeals (count: Int, products: Price): Int = {
//     (count % products.numForDeal) * products.price
//   }

//   //get the price for item that have no deal
//   def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
//     count * products.price
//   }

//   //Remove invalid items and print a warning message
//   def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
//       val valid = for (item <- items) yield {
//           if(!prices.keySet.contains(item)) {
//               //unit to be returned, have as many as you want!!!!!
//               println(item  + " is an invalid item")
//               //final return item from for loop!!!
//               ""
//           } else {
//               item
//           }
//       }
//       valid.mkString("")
//   }

//   //Function to create the tobuy map
//   def createToBuyMap (items: String): Map[Char, Int] = {
//       (for {
//       x <- items
//       i = items.count(_ == x) 
//       } yield (x -> i)).toMap
//     } 

//     def total(vals: String, prod: Map[Char, Price]): String = {
//       val tot = for ((key,value) <- createToBuyMap(vals)) yield {
//         // add function to check  if item is valid 
//         if(prices(key).numForDeal == 0) {
//           (priceWhenItemHasNoDealValues(value, prod(key)))
//         } else {
//           priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
//         }
//       }
//       "Total " + tot.mkString("")
//     }
  
    
}
[0m2021.03.27 19:32:34 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    
  
    
  def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:32:37 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  // def total(vals: String, prod: Map[Char, Price]): String = {
  //     val tot = for ((key,value) <- createToBuyMap(vals)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prod(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
  //       }
  //     }
  //     "Total " + tot.mkString("")
  //   }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  // def total(vals: String, prod: Map[Char, Price]): String = {
  //     val tot = for ((key,value) <- createToBuyMap(vals)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prod(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
  //       }
  //     }
  //     "Total " + tot.mkString("")
  //   }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
import Yoots._

object Main extends App {

  // //make case class
  // case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  // //Map of classes for item prices
  // val prices = Map('a' -> Price(50, 3, 130), 
  //                   'b' -> Price(30, 2, 45), 
  //                   'c' -> Price(20, 0, 0), 
  //                   'd' -> Price(15, 0, 0))

  
  // //Get the price for any deals made
  // def priceForDeals (count: Int, products: Price): Int = {
  //   (count / products.numForDeal) * products.priceForDeal
  // }

  // //Get the price for item that didnt make deal.
  // def priceForNoDeals (count: Int, products: Price): Int = {
  //   (count % products.numForDeal) * products.price
  // }

  // //get the price for item that have no deal
  // def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
  //   count * products.price
  // }

  // //Remove invalid items and print a warning message
  // def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
  //     val valid = for (item <- items) yield {
  //         if(!prices.keySet.contains(item)) {
  //             //unit to be returned, have as many as you want!!!!!
  //             println(item  + " is an invalid item")
  //             //final return item from for loop!!!
  //             ""
  //         } else {
  //             item
  //         }
  //     }
  //     valid.mkString("")
  // }

  // //Function to create the tobuy map
  // def createToBuyMap (items: String): Map[Char, Int] = {
  //     (for {
  //     x <- items
  //     i = items.count(_ == x) 
  //     } yield (x -> i)).toMap
  //   } 

    
  
    
  // def total(vals: String, prod: Map[Char, Price]): String = {
  //     val tot = for ((key,value) <- createToBuyMap(vals)) yield {
  //       // add function to check  if item is valid 
  //       if(prices(key).numForDeal == 0) {
  //         (priceWhenItemHasNoDealValues(value, prod(key)))
  //       } else {
  //         priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
  //       }
  //     }
  //     "Total " + tot.mkString("")
  //   }
  
  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
[0m2021.03.27 19:32:53 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Main.scala[0m
import Yoots._

object Main extends App {

  //Get the items to be bought
  val items = scala.io.StdIn.readLine("Enter items list eg: abcd :-")

  //create a new string of valid items only.
  val valid = removeInvalidItems(items, prices)

  //Get the total cost   
  println(total(valid, prices))

//end
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
[0m2021.03.27 19:38:55 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.sum
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.sum
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.sum
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.sum
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.sum
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.sum
    }
  
    
}
[0m2021.03.27 19:39:44 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
[0m2021.03.27 19:40:08 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toInt
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toInt
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toInt
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toInt
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toInt
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot.toInt
    }
  
    
}
[0m2021.03.27 19:40:57 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
    }
  
    
}
[0m2021.03.27 19:41:10 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
      t
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
      t
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
      t
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
      t
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
      t
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
      t
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
      t
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val t = tot.toInt
      t
    }
  
    
}
[0m2021.03.27 19:41:16 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
[0m2021.03.27 19:41:53 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
[0m2021.03.27 19:42:32 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
[0m2021.03.27 19:42:58 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }.sum
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }.sum
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }.sum
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }.sum
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }.sum
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }.sum
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }.sum
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }.sum
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }.sum
      tot
    }
  
    
}
[0m2021.03.27 19:43:12 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }tot
      
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }tot
      
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }tot
      
    }
  
    
}
[0m2021.03.27 19:43:16 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
[0m2021.03.27 19:43:22 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
[0m2021.03.27 19:43:40 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
[0m2021.03.27 19:43:45 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

  //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      tot
    }
  
    
}
[0m2021.03.27 19:43:54 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      "Total " + tot.mkString("")
    }
  
    
}
[0m2021.03.27 19:44:31 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toint
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toint
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toint
      "Total " + tot.mkString("")
    }
  
    
}
[0m2021.03.27 19:44:33 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toInt
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toInt
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toInt
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toInt
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toInt
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toInt
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toInt
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.toInt
      "Total " + tot.mkString("")
    }
  
    
}
[0m2021.03.27 19:44:47 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.count
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.count
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.count
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.count
      "Total " + tot.mkString("")
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val o = tot.count
      "Total " + tot.mkString("")
    }
  
    
}
[0m2021.03.27 19:45:03 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot
    }
  
    
}
[0m2021.03.27 19:45:11 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
[0m2021.03.27 19:45:25 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
[0m2021.03.27 19:46:29 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      
      tot.toString
    }
  
    
}
[0m2021.03.27 19:47:44 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m tot.sum
      tot.toString
    }
  
    
}
Mar 27, 2021 7:47:44 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FYoots.scala:57: error: illegal start of simple pattern
      val m tot.sum
               ^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FYoots.scala:57: error: illegal start of simple pattern
      val m tot.sum
               ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.badPattern3(ScalametaParser.scala:3305)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.badPattern3$(ScalametaParser.scala:3281)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.badPattern3(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.$anonfun$pattern3$2(ScalametaParser.scala:3272)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.$anonfun$simplePattern$2(ScalametaParser.scala:3379)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.simplePattern(ScalametaParser.scala:3312)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.simplePattern$(ScalametaParser.scala:3311)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.simplePattern(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.loop$8(ScalametaParser.scala:3272)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern3(ScalametaParser.scala:3278)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern3$(ScalametaParser.scala:3258)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.pattern3(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.$anonfun$pattern2$1(ScalametaParser.scala:3226)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern2(ScalametaParser.scala:3225)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern2$(ScalametaParser.scala:3225)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.pattern2(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$patDefOrDcl$2(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$patDefOrDcl$1(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.patDefOrDcl(ScalametaParser.scala:3993)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3959)
	at scala.meta.internal.parsers.ScalametaParser.localDef(ScalametaParser.scala:4913)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4940)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4700)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m tot.sum
      tot.toString
    }
  
    
}
Mar 27, 2021 7:47:49 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FYoots.scala:57: error: illegal start of simple pattern
      val m tot.sum
               ^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FYoots.scala:57: error: illegal start of simple pattern
      val m tot.sum
               ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.badPattern3(ScalametaParser.scala:3305)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.badPattern3$(ScalametaParser.scala:3281)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.badPattern3(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.$anonfun$pattern3$2(ScalametaParser.scala:3272)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.$anonfun$simplePattern$2(ScalametaParser.scala:3379)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.simplePattern(ScalametaParser.scala:3312)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.simplePattern$(ScalametaParser.scala:3311)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.simplePattern(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.loop$8(ScalametaParser.scala:3272)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern3(ScalametaParser.scala:3278)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern3$(ScalametaParser.scala:3258)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.pattern3(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.$anonfun$pattern2$1(ScalametaParser.scala:3226)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern2(ScalametaParser.scala:3225)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern2$(ScalametaParser.scala:3225)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.pattern2(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$patDefOrDcl$2(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$patDefOrDcl$1(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.patDefOrDcl(ScalametaParser.scala:3993)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3959)
	at scala.meta.internal.parsers.ScalametaParser.localDef(ScalametaParser.scala:4913)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4940)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4700)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m tot.sum
      tot.toString
    }
  
    
}
Mar 27, 2021 7:47:50 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FYoots.scala:57: error: illegal start of simple pattern
      val m tot.sum
               ^
file%3A%2F%2F%2FUsers%2Fbenomac%2Fcode%2Fscala%2Fshopping%2Fshopping%2Fsrc%2Fmain%2Fscala%2FYoots.scala:57: error: illegal start of simple pattern
      val m tot.sum
               ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.badPattern3(ScalametaParser.scala:3305)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.badPattern3$(ScalametaParser.scala:3281)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.badPattern3(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.$anonfun$pattern3$2(ScalametaParser.scala:3272)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.$anonfun$simplePattern$2(ScalametaParser.scala:3379)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.simplePattern(ScalametaParser.scala:3312)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.simplePattern$(ScalametaParser.scala:3311)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.simplePattern(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.loop$8(ScalametaParser.scala:3272)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern3(ScalametaParser.scala:3278)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern3$(ScalametaParser.scala:3258)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.pattern3(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.$anonfun$pattern2$1(ScalametaParser.scala:3226)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern2(ScalametaParser.scala:3225)
	at scala.meta.internal.parsers.ScalametaParser$SeqContextSensitive.pattern2$(ScalametaParser.scala:3225)
	at scala.meta.internal.parsers.ScalametaParser$noSeq$.pattern2(ScalametaParser.scala:3392)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$patDefOrDcl$2(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$patDefOrDcl$1(ScalametaParser.scala:3999)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.patDefOrDcl(ScalametaParser.scala:3993)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3959)
	at scala.meta.internal.parsers.ScalametaParser.localDef(ScalametaParser.scala:4913)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4940)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$block$1(ScalametaParser.scala:3002)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.block(ScalametaParser.scala:2995)
	at scala.meta.internal.parsers.ScalametaParser.blockOrCase$1(ScalametaParser.scala:2983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$3(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockExpr$1(ScalametaParser.scala:2986)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.blockExpr(ScalametaParser.scala:2979)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2802)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4700)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.27 19:47:50 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString
    }
  
    
}
[0m2021.03.27 19:47:55 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
[0m2021.03.27 19:48:06 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      
      
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      
      
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      
      
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      
      
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      
      
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      
      
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      
      
    }
  
    
}
[0m2021.03.27 19:48:23 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString
    }
  
    
}
[0m2021.03.27 19:48:50 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString + m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString + m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString + m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString + m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      tot.toString + m
    }
  
    
}
[0m2021.03.27 19:49:08 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
[0m2021.03.27 19:49:14 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val m = tot.sum
      m
    }
  
    
}
[0m2021.03.27 19:49:52 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): Int = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
[0m2021.03.27 19:50:03 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
[0m2021.03.27 19:50:42 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      numTot = tot.sum
      "Total " + numTot
    }
  
    
}
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      numTot = tot.sum
      "Total " + numTot
    }
  
    
}
[0m2021.03.27 19:50:45 WARN  no build target for: /Users/benomac/code/scala/shopping/shopping/src/main/scala/Yoots.scala[0m
object Yoots {
    
    case class Price (price: Int, numForDeal: Int, priceForDeal: Int)

  //Map of classes for item prices
  val prices = Map('a' -> Price(50, 3, 130), 
                    'b' -> Price(30, 2, 45), 
                    'c' -> Price(20, 0, 0), 
                    'd' -> Price(15, 0, 0))
    
    def priceForDeals (count: Int, products: Price): Int = {
    (count / products.numForDeal) * products.priceForDeal
  }

//   //Get the price for item that didnt make deal.
  def priceForNoDeals (count: Int, products: Price): Int = {
    (count % products.numForDeal) * products.price
  }

  //get the price for item that have no deal
  def priceWhenItemHasNoDealValues (count: Int, products: Price): Int = {
    count * products.price
  }

  //Remove invalid items and print a warning message
  def removeInvalidItems (items: String, products: Map[Char, Price]): String = {
      val valid = for (item <- items) yield {
          if(!prices.keySet.contains(item)) {
              //unit to be returned, have as many as you want!!!!!
              println(item  + " is an invalid item")
              //final return item from for loop!!!
              ""
          } else {
              item
          }
      }
      valid.mkString("")
  }

  //Function to create the tobuy map
  def createToBuyMap (items: String): Map[Char, Int] = {
      (for {
      x <- items
      i = items.count(_ == x) 
      } yield (x -> i)).toMap
    } 

    def total(vals: String, prod: Map[Char, Price]): String = {
      val tot = for ((key,value) <- createToBuyMap(vals)) yield {
        // add function to check  if item is valid 
        if(prices(key).numForDeal == 0) {
          (priceWhenItemHasNoDealValues(value, prod(key)))
        } else {
          priceForDeals(value, prices(key)) + priceForNoDeals(value, prod(key))
        }
      }
      val numTot = tot.sum
      "Total " + numTot
    }
  
    
}
